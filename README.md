


<div dir="rtl" class="markdown prose w-full break-words dark:prose-invert light"><p>در اینجا به معرفی و توضیح الگوهای طراحی
    (Design Patterns) که در این برنامه استفاده شده‌اند می‌پردازم و کلاس‌های مربوطه را نیز مشخص می‌کنم، بدون پیاده‌سازی
    کد.</p>
    <h3>1. الگوی طراحی Command</h3><h4>توضیحات</h4>
    <p>الگوی Command برای جدا کردن فرستنده درخواست از دریافت‌کننده درخواست استفاده می‌شود. این الگو به ما امکان می‌دهد
        تا درخواست‌ها را به عنوان اشیاء در نظر بگیریم و به این ترتیب، درخواست‌ها را ذخیره، زمان‌بندی و ثبت کنیم.</p><h4>
        کلاس‌ها</h4>
    <ul>
        <li><strong>Command.java</strong>: رابطی که همه دستورات باید آن را پیاده‌سازی کنند.</li>
        <li><strong>PressKeyCommand.java</strong>: یک کلاس مشخص که فرمان فشردن کلید را پیاده‌سازی می‌کند.</li>
    </ul>
    <h3>2. الگوی طراحی Observer</h3><h4>توضیحات</h4>
    <p>الگوی Observer به اشیاء اجازه می‌دهد تا از تغییرات یک شیء دیگر باخبر شوند. این الگو معمولاً در مواقعی که یک شیء
        باید وضعیت خود را به چندین شیء دیگر اطلاع دهد، استفاده می‌شود.</p><h4>کلاس‌ها</h4>
    <ul>
        <li><strong>Observer.java</strong>: رابطی که مشاهده‌گرها باید آن را پیاده‌سازی کنند.</li>
        <li><strong>Subject.java</strong>: کلاسی که وظیفه اطلاع‌رسانی به مشاهده‌گرها را دارد.</li>
        <li><strong>Lamp.java</strong>: یک کلاس مشاهده‌گر که به تغییرات وضعیت کلیدها واکنش نشان می‌دهد.</li>
    </ul>
    <h3>3. الگوی طراحی Singleton</h3><h4>توضیحات</h4>
    <p>الگوی Singleton اطمینان می‌دهد که تنها یک نمونه از یک کلاس وجود داشته باشد و این نمونه به صورت سراسری قابل دسترسی
        باشد.</p><h4>کلاس‌ها</h4>
    <ul>
        <li><strong>LampContext.java</strong>: کلاسی که به صورت Singleton پیاده‌سازی شده است و تنها یک نمونه از آن در
            برنامه وجود دارد.
        </li>
    </ul>
    <h3>4. الگوی طراحی State</h3><h4>توضیحات</h4>
    <p>الگوی State به یک شیء اجازه می‌دهد تا رفتار خود را بر اساس وضعیت داخلی خود تغییر دهد. این الگو وضعیت‌های مختلف یک
        شیء را به کلاس‌های جداگانه تقسیم می‌کند.</p><h4>کلاس‌ها</h4>
    <ul>
        <li><strong>State.java</strong>: رابطی که تمامی وضعیت‌ها باید آن را پیاده‌سازی کنند.</li>
        <li><strong>InitialState.java</strong>: پیاده‌سازی مشخصی از یک وضعیت.</li>
    </ul>
    <h3>5. الگوی طراحی Memento</h3><h4>توضیحات</h4>
    <p>الگوی Memento برای ذخیره و بازیابی وضعیت داخلی یک شیء بدون افشای جزئیات پیاده‌سازی آن استفاده می‌شود.</p><h4>
        کلاس‌ها</h4>
    <ul>
        <li><strong>Memento.java</strong>: کلاسی که وضعیت شیء را ذخیره می‌کند.</li>
    </ul>
    <h3>6. الگوی طراحی Chain of Responsibility</h3><h4>توضیحات</h4>
    <p>الگوی Chain of Responsibility به ما اجازه می‌دهد تا یک درخواست را از طریق یک زنجیره از پردازشگرها ارسال کنیم تا
        یکی از آن‌ها مسئولیت پردازش درخواست را بر عهده گیرد.</p><h4>کلاس‌ها</h4>
    <ul>
        <li><strong>KeyHandler.java</strong>: کلاس انتزاعی برای پردازش درخواست‌ها.</li>
        <li><strong>ConcreteKeyHandler.java</strong>: پیاده‌سازی مشخصی از KeyHandler برای پردازش درخواست‌های فشردن کلید.
        </li>
        <li><strong>ChainBuilder.java</strong>: کلاسی برای ساخت زنجیره‌ای از پردازشگرهای کلید.</li>
    </ul>
</div>
<div dir="rtl">
<h3>اجرای پروژه</h3>
<p>برای اجرای تست‌ها و اطمینان از کارکرد صحیح کد، می‌توانید از دستورات Maven استفاده کنید:</p>
</div>
mvn test
